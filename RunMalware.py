import ConfigParser
import string
import time
import shutil
import Detect
import os
import logging
import subprocess
import socket
import telnetlib


class ProcessingFailed(Exception):
    pass


class NotRunning(Exception):
    pass


class PackingFailed(Exception):
    pass


class ConfigFailed(Exception):
    pass


class RunMalware():
    def __init__(self, configuration_filename, vm_section_name, sample_name, sample_sha1, instance, logging_queue):
        self.handles = []

        Detect.set_paths(configuration_filename)

        self.__logging_queue = logging_queue
        if not os.path.isfile(configuration_filename):
            raise ConfigFailed("[instance=%d] configuration_filename is not a file" % instance)

        if instance < 1:
            raise ConfigFailed("[instance=%d] instance must be greater than 0" % instance)

        self.config = ConfigParser.ConfigParser()
        self.config.read(configuration_filename)

        self.vm_section_name = vm_section_name

        self.sample_name = sample_name
        self.sample_sha1 = sample_sha1
        self.instance = int(instance)
        self.monitor_port = 1234 + self.instance

        self.working_directory = None

        self.execution_time = None
        self.panda_directory = None
        self.panda_exe = None
        self.results_directory = None
        self.sample_results_directory = None
        self.pcap_filename = None
        self.malware_execution_path = None
        self.replay_base = None
        self.qcow_location = None
        self.revert_instead_of_copy = None
        self.refresh_network = None
        self.snapshot_name = None
        self.cmd_open = None
        self.auto_play_disabled = None
        self.compress_replay = None
        self.vm_memory = None
        self.delete_original = None
        self.work_in_working = None

        self.host_filename = None
        self.file_type = None
        self.agent_filename = None
        self.run_command = None
        self.iso_file = None
        self.new_qcow = None
        self.panda_process = None

        self.monitor_tries = 10
        self.__monitor = None

        self.run_id = None

        self.__keymap = {'-': 'minus',
                         '=': 'equal',
                         '[': 'bracket_left',
                         ']': 'bracket_right',
                         ';': 'semicolon',
                         '\'': 'apostrophe',
                         '\\': 'backslash',
                         ',': 'comma',
                         '.': 'dot',
                         '/': 'slash',
                         '*': 'asterisk',
                         ' ': 'spc',
                         '_': 'shift-minus',
                         '+': 'shift-equal',
                         '{': 'shift-bracket_left',
                         '}': 'shift-bracket_right',
                         ':': 'shift-semicolon',
                         '"': 'shift-apostrophe',
                         '|': 'shift-backslash',
                         '<': 'shift-comma',
                         '>': 'shift-dot',
                         '?': 'shift-slash',
                         '\n': 'ret',
                         '%': 'shift-5',
                         }

    def __get_config(self, config):
        self.working_directory = self.config.get('Main', 'working_directory')
        if not os.path.isdir(self.working_directory):
            os.makedirs(self.working_directory)

        self.results_directory = config.get('Main', 'results_directory')
        if not os.path.isdir(self.results_directory):
            os.makedirs(self.results_directory)

        self.work_in_working = config.getboolean('Main', 'work_in_working')

        if self.work_in_working:
            self.sample_results_directory = os.path.join(self.working_directory, self.sample_sha1)
        else:
            self.sample_results_directory = os.path.join(self.results_directory, self.sample_sha1)
        if not os.path.isdir(self.sample_results_directory):
            os.mkdir(self.sample_results_directory)

        self.run_id = (self.instance, self.sample_name, self.sample_results_directory)

        try:
            self.execution_time = int(config.get('Analysis', 'execution_time'))
        except ValueError:
            raise ConfigFailed("[instance=%d] execution_time must be an integer" % self.instance)
        if self.execution_time <= 0:
            raise ConfigFailed("[instance=%d] execution_time must be greater than 0" % self.instance)

        self.panda_directory = config.get('Main', 'panda_directory')
        if not os.path.isdir(self.panda_directory):
            raise ConfigFailed("[instance=%d] panda_directory is not a directory" % self.instance)

        self.panda_exe = os.path.join(self.panda_directory, 'qemu', 'x86_64-softmmu', 'qemu-system-x86_64')
        if not os.path.isfile(self.panda_exe):
            raise ConfigFailed("[instance=%d] panda_directory is not a directory or is missing /x86_64-softmmu/qemu-system-x86_64" % self.instance)

        if not os.path.isfile(self.sample_name):
            raise ConfigFailed("[instance=%d] sample_name doesn't exist: %s" % (self.instance, self.sample_name))

        self.pcap_filename = os.path.join(self.sample_results_directory, 'pcap.pcap')
        self.malware_execution_path = config.get(self.vm_section_name, 'malware_execution_path')
        self.replay_base = os.path.join(self.sample_results_directory, 'replay')
        self.qcow_location = config.get(self.vm_section_name, 'qcow_location')
        if not os.path.isfile(self.qcow_location):
            raise ConfigFailed("[instance=%d] qcow doesn't exist: %s" % (self.instance, self.qcow_location))
        self.revert_instead_of_copy = config.getboolean('Analysis', 'revert_instead_of_copy')
        self.refresh_network = config.getboolean('Analysis', 'refresh_network')
        self.snapshot_name = config.get(self.vm_section_name, 'snapshot')
        self.cmd_open = config.getboolean(self.vm_section_name, 'cmd_open')
        self.auto_play_disabled = config.getboolean(self.vm_section_name, 'auto_play_disabled')
        self.compress_replay = config.getboolean('Analysis', 'compress_replay')
        self.vm_memory = config.get('Analysis', 'mem')
        self.delete_original = config.getboolean('Main', 'delete_original')

    def __monitor_command(self, command):
        self.__monitor.write(command)
        return self.__monitor.read_until("(qemu)")

    def __guest_type(self, command):
        message = ''
        for c in command:
            if c in string.ascii_uppercase:
                key = 'shift-' + c.lower()
            else:
                key = self.__keymap.get(c, c)
            message = self.__monitor_command('sendkey {0}\n'.format(key))
            time.sleep(.1)
        return message

    def __startup_message(self):
        try:
            self.__logging_queue.put((logging.INFO, "[instance=%d] Sample: %s" % (self.instance, os.path.basename(self.sample_name)), self.run_id))
            self.__logging_queue.put((logging.INFO, "[instance=%d] MD5: %s" % (self.instance, self.sample_sha1), self.run_id))
        except Exception as ex:
            raise ProcessingFailed(ex)

    def __claim_ownership(self):
        try:
            self.host_filename = os.path.join(self.working_directory, os.path.basename(self.sample_name))
            shutil.copy(self.sample_name, self.host_filename)

            zip_file = os.path.join(self.sample_results_directory, 'file.zip')
            self.__logging_queue.put((logging.INFO, "[instance=%d] Creating Passworded zip: %s" % (self.instance, zip_file), self.run_id))
            zip_ = ['zip', '--password', 'infected', '-j', zip_file, self.host_filename]
            self.__logging_queue.put((logging.DEBUG, "[instance=%d] %s" % (self.instance, zip_), self.run_id))
            zip_process = subprocess.Popen(zip_, stdin=subprocess.PIPE, stdout=subprocess.PIPE, stderr=subprocess.PIPE)
            self.handles.append(['kill', zip_process])
            output, error = zip_process.communicate()
            if output:
                self.__logging_queue.put((logging.DEBUG, "[instance=%d] zip_process: %s" % (self.instance, output), self.run_id))
            if error:
                self.__logging_queue.put((logging.DEBUG, "[instance=%d] zip_process: %s" % (self.instance, error), self.run_id))
        except Exception as ex:
            raise ProcessingFailed(ex)

    def __set_file_type(self):
        try:
            self.file_type = Detect.get_type(self.host_filename)
            if self.file_type:
                self.__logging_queue.put((logging.INFO, "[instance=%d] Detected sample type: %s" % (self.instance, self.file_type), self.run_id))
            else:
                f_type = Detect.get_file_type(self.host_filename).lower()
                self.__logging_queue.put((logging.WARNING, "[instance=%d] Cannot process type: %s." % (self.instance, f_type), self.run_id))
                raise ProcessingFailed()
        except Exception as ex:
            raise ProcessingFailed(ex)

    def __set_extension_host_filename(self):
        try:
            if not self.host_filename.endswith(self.file_type):
                shutil.move(self.host_filename, self.host_filename + "." + self.file_type)
                self.host_filename = self.host_filename + "." + self.file_type
                self.handles.append(['delete', self.host_filename])
        except Exception as ex:
            raise ProcessingFailed(ex)

    def __set_agent_filename(self):
        try:
            self.agent_filename = os.path.basename(self.host_filename)
            self.__logging_queue.put((logging.DEBUG, "[instance=%d] Agent filename is now: %s" % (self.instance, self.agent_filename), self.run_id))
        except Exception as ex:
            raise ProcessingFailed(ex)

    def __set_run_command(self):
        try:
            architecture = Detect.get_pefile_architecture(self.host_filename)
            if architecture == 0:
                architecture = None
            self.run_command = Detect.get_run_command(self.file_type, architecture, self.malware_execution_path + "\\" + self.agent_filename)
            if self.run_command:
                self.__logging_queue.put((logging.DEBUG, "[instance=%d] Run command: %s" % (self.instance, self.run_command), self.run_id))
            else:
                self.__logging_queue.put((logging.ERROR, "[instance=%d] Failed to get run command for: (%s,%s)" % (self.instance, self.file_type, architecture), self.run_id))
                raise ProcessingFailed()
        except Exception as ex:
            raise ProcessingFailed(ex)

    def __make_sample_iso(self):
        try:
            self.iso_file = os.path.join(self.sample_results_directory, 'sample.iso')
            self.handles.append(['delete', self.iso_file])
            self.__logging_queue.put((logging.INFO, "[instance=%d] Creating CD image: %s" % (self.instance, self.iso_file), self.run_id))
            genisoimage = ['/usr/bin/genisoimage', '-iso-level', '4', '-l', '-R', '-J', '-o', self.iso_file, self.host_filename]
            self.__logging_queue.put((logging.DEBUG, "[instance=%d] %s" % (self.instance, genisoimage), self.run_id))
            iso_process = subprocess.Popen(genisoimage, stdin=subprocess.PIPE, stdout=subprocess.PIPE, stderr=subprocess.PIPE)
            self.handles.append(['kill', iso_process])
            output, error = iso_process.communicate()
            if output:
                self.__logging_queue.put((logging.DEBUG, "[instance=%d] iso_process: %s" % (self.instance, output), self.run_id))
            if error:
                self.__logging_queue.put((logging.DEBUG, "[instance=%d] iso_process: %s" % (self.instance, error), self.run_id))
        except Exception as ex:
            raise ProcessingFailed(ex)

    def __revert_qcow(self):
        try:
            if self.revert_instead_of_copy:
                self.new_qcow = self.qcow_location
            else:
                self.new_qcow = os.path.join(self.sample_results_directory, 'win7.{0}.qcow2').format(self.instance)
                if not self.revert_instead_of_copy:
                    self.handles.append(['delete', self.new_qcow])
                self.__logging_queue.put((logging.INFO, "[instance=%d] Copying qcow: %s" % (self.instance, self.qcow_location), self.run_id))
                shutil.copyfile(self.qcow_location, self.new_qcow)
        except Exception as ex:
            raise ProcessingFailed(ex)

    def __start_panda(self):
        try:
            panda_args = [self.panda_exe,
                          '-m', self.vm_memory,
                          '-monitor', 'telnet:localhost:{0},server,nowait'.format(self.monitor_port),
                          '-drive', 'file={0},cache=unsafe'.format(self.new_qcow),
                          # '-record-from', 'bootsys:{0}'.format(self.replay_base),
                          '-net', 'nic,model=e1000',
                          '-net', 'dump,file={0}'.format(self.pcap_filename),
                          '-net', 'user',
                          '-vnc', '127.0.0.1:{0}'.format(self.instance),
                          '-cpu', 'Nehalem'
                          ]

            # Start the QEMU process.
            self.__logging_queue.put((logging.INFO, "[instance=%d] Starting panda" % self.instance, self.run_id))
            self.__logging_queue.put((logging.DEBUG, "[instance=%d] %s" % (self.instance, panda_args), self.run_id))
            panda_stdout = open(os.path.join(self.sample_results_directory, 'panda.stdout'), 'w')
            panda_stderr = open(os.path.join(self.sample_results_directory, 'panda.stderr'), 'w')
            self.panda_process = subprocess.Popen(panda_args, stdin=subprocess.PIPE, stdout=panda_stdout, stderr=panda_stderr)
            self.handles.append(['kill', self.panda_process])
        except Exception as ex:
            raise ProcessingFailed(ex)

    def __get_monitor(self):
        try:
            # Connect to the monitor
            # Give it time to come up...
            for i in range(self.monitor_tries):
                try:
                    self.__logging_queue.put((logging.INFO, "[instance=%d] Connecting to monitor, try %d/%d" % (self.instance, i, self.monitor_tries), self.run_id))
                    self.__monitor = telnetlib.Telnet('localhost', self.monitor_port)
                    self.handles.append(['close', self.__monitor])
                    break
                except socket.error:
                    time.sleep(1)

            if not self.__monitor:
                self.__logging_queue.put((logging.CRITICAL, "[instance=%d] Couldn't connect to monitor on port %d" % (self.instance, self.monitor_port), self.run_id))
                try:
                    self.panda_process.kill()
                except:
                    pass
                raise ProcessingFailed()
            else:
                self.__logging_queue.put((logging.INFO, "[instance=%d] Successfully connected to monitor on port %d" % (self.instance, self.monitor_port), self.run_id))
        except Exception as ex:
            raise NotRunning(ex)

    def __wait_for_qemu(self):
        try:
            self.__monitor.read_until("(qemu)")
        except Exception as ex:
            raise NotRunning(ex)

    def __revert_to_snapshot(self):
        try:
            self.__logging_queue.put((logging.INFO, "[instance=%d] Reverting to snapshot: %s" % (self.instance, self.snapshot_name), self.run_id))
            message = self.__monitor_command('loadvm %s\n' % self.snapshot_name)
            # self.__logging_queue.put((logging.DEBUG, "[instance=%d] %s" % (self.instance, message), self.run_id))
        except Exception as ex:
            raise NotRunning(ex)

    def __mount_cd(self, wait_time):
        try:
            self.__logging_queue.put((logging.INFO, "[instance=%d] Mounting CD image" % self.instance, self.run_id))
            message = self.__monitor_command('change ide1-cd0 {0}\n'.format(self.iso_file))
            # self.__logging_queue.put((logging.DEBUG, "[instance=%d] %s" % (self.instance, message), self.run_id))
            time.sleep(wait_time)
        except Exception as ex:
            raise NotRunning(ex)

    def __escape_auto_run(self, wait_time):
        try:
            if not self.auto_play_disabled:
                # Get rid of the CD dialog
                self.__logging_queue.put((logging.INFO, "[instance=%d] Getting rid of CD autoplay dialog" % self.instance, self.run_id))
                message = self.__monitor_command('sendkey esc\n')
                # self.__logging_queue.put((logging.DEBUG, "[instance=%d] %s" % (self.instance, message), self.run_id))
                time.sleep(wait_time)
        except Exception as ex:
            raise NotRunning(ex)

    def __network_refresh(self, wait_time):
        try:
            if self.refresh_network:
                self.__logging_queue.put((logging.INFO, "[instance=%d] Renewing DHCP lease" % self.instance, self.run_id))
                message = self.__guest_type(r"ipconfig /renew" + '\n')
                # self.__logging_queue.put((logging.DEBUG, "[instance=%d] %s" % (self.instance, message), self.run_id))
                time.sleep(wait_time)
        except Exception as ex:
            raise NotRunning(ex)

    def __copy_from_cd(self, wait_time):
        try:
            self.__logging_queue.put((logging.INFO, "[instance=%d] Copying file to desktop" % self.instance, self.run_id))
            message = self.__guest_type(r'copy "D:\\' + os.path.basename(self.agent_filename) + '" "' + self.malware_execution_path + '"\n')
            # self.__logging_queue.put((logging.DEBUG, "[instance=%d] %s" % (self.instance, message), self.run_id))
            time.sleep(wait_time)
        except Exception as ex:
            raise NotRunning(ex)

    def __type_run_command(self):
        try:
            self.__logging_queue.put((logging.INFO, "[instance=%d] Typing run command" % self.instance, self.run_id))
            message = self.__guest_type(self.run_command)
            # self.__logging_queue.put((logging.DEBUG, "[instance=%d] %s" % (self.instance, message), self.run_id))
        except Exception as ex:
            raise NotRunning(ex)

    def __start_panda_record(self):
        try:
            self.__logging_queue.put((logging.INFO, "[instance=%d] Starting PANDA record" % self.instance, self.run_id))
            message = self.__monitor_command("begin_record {0}\n".format(self.replay_base))
            # self.__logging_queue.put((logging.DEBUG, "[instance=%d] %s" % (self.instance, message), self.run_id))
        except Exception as ex:
            raise NotRunning(ex)

    def __start_sample(self):
        try:
            self.__logging_queue.put((logging.INFO, "[instance=%d] Starting sample" % self.instance, self.run_id))
            message = self.__guest_type('\n')
            # self.__logging_queue.put((logging.DEBUG, "[instance=%d] %s" % (self.instance, message), self.run_id))
        except Exception as ex:
            raise NotRunning(ex)

    def __end_panda_record(self):
        try:
            self.__logging_queue.put((logging.INFO, "[instance=%d] Ending record" % self.instance, self.run_id))
            message = self.__monitor_command("end_record\n")
            # self.__logging_queue.put((logging.DEBUG, "[instance=%d] %s" % (self.instance, message), self.run_id))
            self.__logging_queue.put((logging.INFO, "[instance=%d] Quitting PANDA" % self.instance, self.run_id))
            self.__monitor.write("q\n")
        except Exception as ex:
            raise NotRunning(ex)

    def __pack_sample(self):
        try:
            if self.compress_replay:
                self.__logging_queue.put((logging.INFO, "[instance=%d] RRPacking replay" % self.instance, self.run_id))
                if os.path.isfile(self.replay_base + '-rr-snp') and os.path.isfile(self.replay_base + '-rr-nondet.log'):
                    rr_pack_filename = os.path.join(self.panda_directory, 'scripts', 'rrpack.py')
                    self.__logging_queue.put((logging.INFO, "[instance=%d] Packing replay %s" % (self.instance, self.replay_base), self.run_id))
                    rr_pack = ['python', rr_pack_filename, self.replay_base]
                    self.__logging_queue.put((logging.DEBUG, "[instance=%d] %s" % (self.instance, rr_pack), self.run_id))
                    rr_pack_process = subprocess.Popen(rr_pack, stdin=subprocess.PIPE, stdout=subprocess.PIPE, stderr=subprocess.STDOUT)
                    self.handles.append(['kill', rr_pack_process])

                    output, error = rr_pack_process.communicate()
                    if output:
                        self.__logging_queue.put((logging.DEBUG, "[instance=%d] RRPack: %s" % (self.instance, output), self.run_id))
                    if error:
                        self.__logging_queue.put((logging.WARNING, "[instance=%d] RRPack: %s" % (self.instance, error), self.run_id))

                    if os.path.isfile(self.replay_base + '.rr'):
                        self.handles.append(['delete', self.replay_base + '-rr-snp'])
                        self.handles.append(['delete', self.replay_base + '-rr-nondet.log'])
                else:
                    self.__logging_queue.put((logging.CRITICAL, "[instance=%d] Could not find replay files -rr-snp/-rr-nondet.log" % self.instance, self.run_id))
        except Exception as ex:
            raise PackingFailed(ex)

    def __clean_up(self):
        try:
            for handle in self.handles:
                try:
                    if handle[0] == 'delete':
                        if os.path.isfile(handle[1]):
                            os.unlink(handle[1])
                    elif handle[0] == 'close':
                        if handle[1]:
                            handle[1].close()
                    elif handle[0] == 'kill':
                        if handle[1] and not handle[1].poll():
                            handle[1].kill()
                except:
                    pass

            if self.delete_original:
                if self.sample_name and os.path.isfile(self.sample_name):
                    self.__logging_queue.put((logging.DEBUG, "[instance=%d] Deleting: %s" % (self.instance, self.sample_name), self.run_id))
                    os.unlink(self.sample_name)
        except Exception as ex:
            self.__logging_queue.put((logging.CRITICAL, "[instance=%d] Clean up failed: %s" % (self.instance, ex.message), self.run_id))

    def run(self):
        ran = True
        packed = True
        panda_initialization_time = None
        sample_time = None
        pack_time = None

        start_time = time.time()
        try:
            self.__get_config(self.config)

            if os.path.isdir(os.path.join(self.results_directory, self.sample_sha1)):
                self.__logging_queue.put((logging.WARNING, "[instance=%d] Sample already exists at: %s" % (self.instance, os.path.join(self.results_directory, self.sample_sha1)), self.run_id))
                # Stop the logging of this run
                self.__logging_queue.put((logging.INFO, "STOP_LOGGING", self.run_id))
                return False

            self.__startup_message()
            self.__claim_ownership()
            self.__set_file_type()
            self.__set_extension_host_filename()
            self.__set_agent_filename()
            self.__set_run_command()
            self.__make_sample_iso()
            self.__revert_qcow()
            panda_start_time = time.time()
            self.__start_panda()
            self.__get_monitor()
            self.__wait_for_qemu()
            self.__revert_to_snapshot()
            self.__mount_cd(10)
            self.__escape_auto_run(5)
            self.__network_refresh(30)
            self.__copy_from_cd(5)
            self.__type_run_command()
            panda_initialization_time = time.time() - panda_start_time
            self.__start_panda_record()

            self.__start_sample()
            sample_start_time = time.time()

            # Let the sample run
            self.__logging_queue.put((logging.INFO, "[instance=%d] Sleeping for %d seconds..." % (self.instance, self.execution_time), self.run_id))
            time.sleep(self.execution_time)

            self.__end_panda_record()
            sample_time = time.time() - sample_start_time

            pack_start_time = time.time()
            self.__pack_sample()
            pack_time = time.time() - pack_start_time
        except ConfigFailed as ex:
            self.__logging_queue.put((logging.CRITICAL, "[instance=%d] ConfigFailed: %s" % (self.instance, ex.message), self.run_id))
            # Stop the logging of this run
            self.__logging_queue.put((logging.INFO, "STOP_LOGGING", self.run_id))
            return False
        except ProcessingFailed as ex:
            self.__logging_queue.put((logging.CRITICAL, "[instance=%d] ProcessingFailed: %s" % (self.instance, ex.message), self.run_id))
            ran = False
            packed = False
        except NotRunning as ex:
            self.__logging_queue.put((logging.CRITICAL, "[instance=%d] NotRunning: %s" % (self.instance, ex.message), self.run_id))
        except PackingFailed as ex:
            self.__logging_queue.put((logging.CRITICAL, "[instance=%d] PackingFailed: %s" % (self.instance, ex.message), self.run_id))
            packed = False

        cleaning_start_time = time.time()
        self.__clean_up()
        cleanup_time = time.time() - cleaning_start_time

        move_start_time = time.time()
        if self.work_in_working:
            shutil.move(self.sample_results_directory, self.results_directory)
        move_time = time.time() - move_start_time

        total_time = time.time() - start_time

        times = {'total': total_time, 'cleanup_time': cleanup_time}

        if ran:
            self.__logging_queue.put((logging.INFO, "[instance=%d] Run complete" % self.instance, self.run_id))
            times['panda_initialization_time'] = panda_initialization_time
            times['sample_time'] = sample_time
        if packed:
            times['pack_time'] = pack_time
        if self.work_in_working:
            times['move_time'] = move_time

        self.__logging_queue.put((logging.INFO, "[instance=%d] Times: %s" % (self.instance, str(times)), self.run_id))

        # Stop the logging of this run
        self.__logging_queue.put((logging.INFO, "STOP_LOGGING", self.run_id))

        return self.sample_results_directory